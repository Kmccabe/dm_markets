import random as rnd
import operator
import os
import matplotlib.pyplot as plt                 # import matplotlib
import numpy as np                              # import numpy
import time
import copy
import json
import pprint
import dm_bargain
import dm_travel
import dm_agents
import dm_env as env
import dm_utils as dm

class SimulateMarket(object):
    """Simulate a market on grid of consisting of weeks and days using two types of trading agents"""

    def __init__(self, sim_name, num_weeks, num_periods, num_rounds, num_traders, trader_types, grid_size, num_units , debug, plot_on):

        self.sim_name = sim_name             # simulation name
        self.num_weeks = num_weeks           # simulation weeks
        self.num_periods = num_periods       # simulation periods(days) for a week
        self.num_rounds = num_rounds         # number of bargaining rounds for a day
        self.trader_types = trader_types     # list of two trader types, should be tuple
        self.grid_size = grid_size            # simulation grid size: square
        self.num_traders = num_traders       # number of traders divisible by two
        self.num_units = num_units           # number of units, same for all traders
        self.debug = debug                   # if True print additional information
        self.plot_on = plot_on               # if True plot every week, otherwsie plot last week

        self.current_week = 0                # Int index for week
        self.location_list = []              # initial location list for all traders
        self.trader_dic = {}                 # trader list for all weeks
        self.results_whole = {}              # whole simulation results
                                             #(moving history, market conditions), key = week
        self.auction = None      # double auction object
        self.auction_limits = (999, 0)  # tuple of limits, (max bid, min ask)
        self.market = None       # market environment object
        self.traders = None      # list of participating trader class names
        self.trader_list = None  # list of initialized trader objects
        self.prices = {}         # dic of prices from contracts, key = week
        self.contracts = {}      # dic of full contracts, key = week

        self.buyer_surplus = None   # Surplus generate by buyers. Sum of (value-price)
        self.seller_surplus = None  # Surplus generated by sellers.  Sum of (price-cost)
        self.actual_surplus = None  # Sum of buyer surplus and seller surplus
        self.efficiency = None      # (actual_surplus/eq_max_surplus) * 100.
        self.type_surplus = {}
        self.sim_time = [0.0]       # sim_time[0] = round; sim_time[1] = tick


    def gen_location_list(self):
        """Initialize the location list:  Returns a sorted list of location (x, y) 
           drawn from Uniform distribution truncated to be non-negative.
        """
        for i in range(self.num_traders):
            x = rnd.randint(0,self.grid_size-1)
            y = rnd.randint(0,self.grid_size-1)
            self.location_list.append((x, y))

    def build_traders(self):
        """
        build self.traders: name, type, money, initial location
        """
        # replicate trade_object total_traders//2 times and put in traders list
        # make a shuffled list of trader objects for trader roles
        self.gen_location_list()

        self.traders = []
        for k in range(self.num_traders // 2):
            self.traders = self.traders + self.trader_types
        np.random.shuffle(self.traders)

        # Assign trader objects to buyer/seller roles and assign values and costs
        self.trader_list = []
        for t in range(self.num_traders):
            agent = None
            name = f"B_{t+1}"
            trader_type = "BUYER"
            payoff = dm.utility
            money = 500
            if t >= self.num_traders // 2:
                name = f"S_{t + 1 - self.num_traders // 2}"
                trader_type = "SELLER"
                payoff = dm.profit             
            agent_model = self.traders[t]
            agent_kind = str(agent_model.__name__)
            name = f"{name}_{agent_kind}"
            location = self.location_list[t]                                  # get initial location
            agent = agent_model(name, trader_type, payoff, money, location)
            #print(agent)
            self.trader_list.append(agent)

    def make_whole_trader_list(self):
        """
        build self.traders for each week: name, type, payoff, money, initial location
        location will be inherited from last day
        generate new res_values
        """
        if self.current_week == 0:
            self.build_traders()
            if self.debug:
                dm.print_agents(self.trader_list)
                print(self.trader_list)
            self.trader_dic[self.current_week] = self.trader_list
        else:
            trader_list = []
            for i in range(self.num_traders):
                t = self.trader_dic[self.current_week-1][i]
                # agent_model gets the class for agent object t
                agent_model = type(t)
                #print(agent_model)
                agent = agent_model(t.name, t.type, t.payoff, t.money, t.location)   # inherit location
                trader_list.append(agent)
            self.trader_dic[self.current_week] = trader_list
        # add in values and costs    
        for i in range(self.num_traders):
            t = self.trader_dic[self.current_week][i]                 # get single trader class instance
            values = self.gen_res_values(True, mu=400, sigma=200)     # generate values if traders is buyer
            t.set_values(values)
            if i >= self.num_traders//2:
                costs = sorted(values, reverse=False)                 # Convert values to costs
                t.set_costs(costs)
            t.get_simulation(self)                                    # trader can get access to simulation results.
        #dm.print_agents(self.trader_list)

    def match_found(self, agents):
        """Checks to see if there is at least one buyer and one seller at a location to allow bargaining"""
        match = False
        buyer_found = False
        seller_found = False
        for agent in agents:
            if agent.type == "BUYER":
                buyer_found = True
            if agent.type == "SELLER":
                seller_found = True
        if buyer_found and seller_found:
            match = True
        return match

    def run_simulation(self):
        """ Runs a simulation for a week:
                Each day: 
                    agents make travel decisions
                    make contracts with agents at the same node"""
        
        # Setup for simulation
        debug = self.debug
        agent_list = self.trader_dic[self.current_week]
        t_inst = dm_travel.Travel(self.grid_size, agent_list, debug)
        t_inst.start_travel()
        b_inst = dm_bargain.Bargain(self.num_rounds)
        self.contracts[self.current_week] = {}
        self.prices[self.current_week] = []
        period_ls = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]

        # Start simulation for week
        for period in range(self.num_periods):
            # contracts are accumulated by day
            self.contracts[self.current_week][period_ls[period]] = []
            print(f"{5 * '='}  {period_ls[period]}")

            # run travel institution to let agents travel
            t_inst.run()
            g = t_inst.get_grid()

            # Walk occupied points in grid and run bargain institution at each point
            period_contracts = []
            for loc in g:
                agents = g[loc]
                # Run bargain if you have a BUYER and A Seller
                if self.match_found(agents):
                    b_inst.set_agents(agents)
                    b_inst.set_debug(self.debug)
                    b_inst.run()
                    loc_contracts = b_inst.get_contracts()
                    period_contracts.extend(loc_contracts)
                    test_test = 1
            self.contracts[self.current_week][period_ls[period]].extend(period_contracts)
            if debug:
                # provide information after a period is processed
                dm.print_agents(self.trader_list)
                t_inst.print_grid()
                print(period, period_ls[period], self.current_week)
                print(self.contracts)
                for agent in agent_list:
                    print(f"{agent.name} transacted {agent.get_units_transacted()}")

        # Finish simulation for week and
        # store moving history to self.result_whole
        self.results_whole[self.current_week] = {}
        history_of_travel = t_inst.get_history()
        self.results_whole[self.current_week]["Moving_History"] = history_of_travel

        # also store prices in self.prices for self.current week
        contracts_in_week = self.contracts[self.current_week]
        # Extract price from each contract in week and put in prices 
        for contract_list in contracts_in_week.values():
            for i in range(len(contract_list)):
                self.prices[self.current_week].append(contract_list[i][1])

    def make_whole_simulation(self):
        """
        make a whole session: multi-week
        """
        for self.current_week in range(self.num_weeks):
            print(f"week = {self.current_week}")
            self.make_whole_trader_list()           # build trader for every week
            self.make_market()                      # set up market environment for plot
            self.run_simulation()                   # run simulation for every week
            if self.plot_on:
                self.plot_prices()                      # plot supply_demand_prices, and save in a folder
            elif self.current_week == self.num_weeks - 1:
                self.plot_prices() 
            self.display_results()                  # display results
            self.get_results()                      # store other parameters(num_trader...) to results_whole
            if self.debug:
                print(self.get_results())

        # save the dict results_whole to a json file, in the same folder where graphs are
        json.dump(self.results_whole, open(str(self.sim_name) + "/Results_json.json", "w"))

    def plot_prices(self):
        #print(self.prices[self.current_week])
        # Save figure in the given folder
        # name = sim_name/Week i
        self.market.plot_supply_demand(name= str(self.sim_name)+"/Week"+str(self.current_week), prices=self.prices[self.current_week])

    def get_results(self):
        """for one week: return results as dictionary"""

        total_price = 0.0
        if len(self.prices[self.current_week]) == 0:
            avg_price = 0
        else:
            for price in self.prices[self.current_week]:
                total_price += price
            avg_price = total_price / len(self.prices[self.current_week])

        eq_units, eq_plow, eq_phigh, eq_max_surplus = self.market.get_equilibrium()
        self.calc_efficiency()

        results = self.results_whole[self.current_week]

        results["name"] = self.sim_name
        results['week'] = self.current_week
        results['num_days'] = self.num_periods                   # record num_days for a week
        results['grid_size'] = self.grid_size
        results["number traders"] = self.num_traders
        results["number units"] = self.num_units

        # TODO Add trader types, values, and costs here

        results["eq low price"] = eq_plow
        results["eq high price"] = eq_phigh
        results["eq quantity"] = eq_units
        results["eq surplus"] = eq_max_surplus

        results["avg price"] = avg_price
        results["prices"] = self.prices[self.current_week]
        results["quantity"] = len(self.prices[self.current_week])

        results["buyer surplus"] = self.buyer_surplus
        results["seller surplus"] = self.seller_surplus
        results["actual surplus"] = self.actual_surplus
        results["efficiency"] = self.efficiency
        for trader_strategy in self.type_surplus[self.current_week]:
            results[trader_strategy] = self.type_surplus[self.current_week][trader_strategy]

        return self.results_whole[self.current_week]


    def make_market(self):
        """Make MarketEnviornment object from traders
        """
        # self.build_traders()
        num_side = self.num_traders // 2
        self.market = env.SpotMarketEnvironment(name="self.sim_name", num_buyers=num_side, num_sellers=num_side)
        for index, trader in enumerate(self.trader_dic[self.current_week]):
            if index < num_side:  # This is a buyer
                values = trader.get_values()
                self.market.add_buyer(index, values)
            else:  # this is a seller
                seller_index = index - num_side  # sellers start at 0 in market environment
                costs = trader.get_costs()
                self.market.add_seller(seller_index, costs)
        self.market.make_demand()
        self.market.make_supply()
        self.market.calc_equilibrium()

    def display_market_equilibrium(self):
        self.market.display_equilibrium()

    def plot_market(self):
        self.market.plot_supply_demand()

    def calc_efficiency(self):
        """
        """

        self.buyer_surplus = 0
        self.seller_surplus = 0
        self.actual_surplus = 0
        self.efficiency = 0

        period_ls = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
        week_contracts = []
        for period in range(self.num_periods):
            period_contracts = self.contracts[self.current_week][period_ls[period]]
            week_contracts.extend(period_contracts) 
        #print("week contracts", len(week_contracts), week_contracts)
        #print("compaison", len(self.prices[self.current_week]))
        self.type_surplus[self.current_week] = {}
        for trader in self.trader_list:
            trader_strategy = trader.name.split("_")[-1]  # trader.name = trader_t_type
            trader_surplus = 0
            unit = 0
            # res = trader.get_value_costs()  # get reservation values (values for buyers costs for sellers)
            for contract in week_contracts:
                #print(contract)
                round_number, price, buyer_name, seller_name = contract
                if trader.type == "BUYER":
                    res = trader.get_values()
                    if trader.name == buyer_name:
                        surplus = res[unit] - price
                        unit = unit + 1
                        trader_surplus = trader_surplus + surplus
                        self.buyer_surplus = self.buyer_surplus + surplus
                        self.type_surplus[self.current_week][trader_strategy] = \
                            self.type_surplus[self.current_week].get(trader_strategy, 0) + surplus
                        #print(res, surplus, self.buyer_surplus)
                        test_test = 1
                else:
                    res = trader.get_costs()
                    if trader.name == seller_name:
                        surplus = price - res[unit]
                        unit = unit + 1
                        trader_surplus = trader_surplus + surplus
                        self.seller_surplus = self.seller_surplus + surplus
                        self.type_surplus[self.current_week][trader_strategy] = \
                            self.type_surplus[self.current_week].get(trader_strategy, 0) + surplus

            self.actual_surplus = self.buyer_surplus + self.seller_surplus
            eq_units, eq_plow, eq_phigh, eq_max_surplus = self.market.get_equilibrium()
            self.efficiency = (self.actual_surplus / eq_max_surplus) * 100.0

    def display_contracts(self):
        """Display a list of contracts"""
        print(f"{'-'*20 } Display Contract")
        for week in range(self.num_weeks):
            print("-"*40 + f"Contracts in Week {week}:")
            for contract in self.contracts[week]:
                round_number, price, buyer_name, seller_name = contract
                print(f"In Round {round_number}, at price {price} Buyer {buyer_name} trades with Seller {seller_name}")

    def display_results(self):
        """Displays a summary of the simulation
        """
        # print("-" * 20 + "Display Results")
        print(f"{40 *'-'} Results in Week {self.current_week}")
        total_price = 0.0
        if len(self.prices[self.current_week]) == 0:
            avg_price = 0
        else:
            for price in self.prices[self.current_week]:
                total_price += price
            avg_price = total_price / len(self.prices[self.current_week])

        eq_units, eq_plow, eq_phigh, eq_max_surplus = self.market.get_equilibrium()
        self.calc_efficiency()

        print(f"Market {self.sim_name} has {self.num_traders} traders, each with {self.num_units} units")
        print(f"      equilibrium price range is {eq_plow} to {eq_phigh}")
        print(f"      average price = {avg_price}")
        print(f"      equilibrium expected contracts = {eq_units}, actual contracts = {len(self.prices[self.current_week])}")
        print(f"      buyer surplus = {self.buyer_surplus}, seller surplus = {self.seller_surplus}")
        print(f"      actual_surplus = {self.actual_surplus}, maximum surplus = {eq_max_surplus}")
        print("      efficiency = {:0.2f}%.\n".format(self.efficiency))
        for trader_strategy in self.type_surplus[self.current_week]:
            print(f"  {trader_strategy} has surplus {self.type_surplus[self.current_week][trader_strategy]}")


    def get_contracts(self):
        return self.auction.get_contracts()

    def gen_res_values(self, buyer_flag, mu=500, sigma=100):
        """Returns a sorted list of values or costs drawn from a Normal distribution truncated to be non-negative
            units = number of draws
            return_values = True (return values), = False (return cost)
            mu = mean of normal distribution
            sigma = standard deviation of normal distribution
        """
        values = []
        unit = 0
        while unit < self.num_units:
            value = round(np.random.randint(sigma, mu))
            if value >= 0:
                values.append(value)
                unit = unit + 1
        if buyer_flag:
            return sorted(values, reverse=True)  # List of values
        else:
            return sorted(values, reverse=False)  # list of costs

    def get_prices(self):
        return self.prices

    def get_traders(self):
        return self.trader_list

    def get_offers(self):
        return self.auction.get_orders()

    def get_buyers(self):
        return self.market.get_buyers()

    def get_sellers(self):
        return self.market.get_sellers()

if __name__ == "__main__":

    ZID = dm_agents.ZID
    ZIDA = dm_agents.ZIDA

    trader_objects = [ZIDA, ZIDA]     # List of artificial traders length 2
    debug = False
    plot_on = False
    num_weeks = 100                   #  Number of weeks
    num_periods = 7                   # Number of days a week
    num_rounds = 60                   # bargaining rounds per day
    grid_size = 8                     # Grid is grid_size x grid_size
    num_traders = 20                  # traders (multiple of two)
    num_units = 10                     # Number of units per trader
    sim_name = "Decentralized-ZIDA-gridsize-10"  # will be the folder name

    if os.path.exists(sim_name):      # delete all files if folder exists
        for files in os.listdir(sim_name):
            file = sim_name +'/' + files
            os.remove(file)
    if not os.path.exists(sim_name):  # create new folder to store result(dict)
        os.makedirs(sim_name)

    sim_mkt = SimulateMarket(sim_name, num_weeks, num_periods, num_rounds, num_traders, trader_objects, grid_size, num_units, debug, plot_on)
    sim_mkt.make_whole_simulation()



